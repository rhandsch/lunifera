/*******************************************************************************
 * Copyright (c) 2011, 2012 Cristiano Gavião - Lunifera.org.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Cristiano Gavião - initial API and implementation
 *******************************************************************************/
/*
 * generated by Xtext
 */
package org.lunifera.metamodel.dsl.software.composition.scoping;

import javax.inject.Inject;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.ScopeBasedSelectable;
import org.eclipse.xtext.scoping.impl.SelectableBasedScope;
import org.lunifera.metamodel.dsl.component.template.library.componentTemplateLibraryDsl.ComponentTemplateLibraryDslPackage;
import org.lunifera.metamodel.dsl.component.template.library.componentTemplateLibraryDsl.CompositionModelType;
import org.lunifera.metamodel.dsl.component.template.library.componentTemplateLibraryDsl.ConstraintLinkType;
import org.lunifera.metamodel.dsl.component.template.library.componentTemplateLibraryDsl.ProvidedCapabilityCapture;
import org.lunifera.metamodel.dsl.component.template.library.componentTemplateLibraryDsl.RequiredCapabilityCapture;
import org.lunifera.metamodel.dsl.component.template.library.componentTemplateLibraryDsl.UnitType;
import org.lunifera.metamodel.dsl.component.template.library.scoping.ComponentTemplateLibraryDslScopeProvider;
import org.lunifera.metamodel.dsl.component.template.library.utils.ComponentTemplateLibraryDslModelUtility;
import org.lunifera.metamodel.dsl.software.composition.compositeModelDsl.CompositeModelDslPackage;
import org.lunifera.metamodel.dsl.software.composition.compositeModelDsl.CompositeModelInstance;
import org.lunifera.metamodel.dsl.software.composition.compositeModelDsl.ConstraintLinkInstance;
import org.lunifera.metamodel.dsl.software.composition.compositeModelDsl.LinkInstance;
import org.lunifera.metamodel.dsl.software.composition.compositeModelDsl.SourceEndPointInstance;
import org.lunifera.metamodel.dsl.software.composition.compositeModelDsl.TargetEndPointInstance;
import org.lunifera.metamodel.dsl.software.composition.compositeModelDsl.UnitInstance;

import com.google.common.base.Predicate;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class CompositeModelDslScopeProvider extends
		ComponentTemplateLibraryDslScopeProvider {

	@Inject
	private IQualifiedNameConverter qualifiedNameConverter;
	@Inject
	private IQualifiedNameProvider qualifiedNameProvider;
	@Inject
	private ComponentTemplateLibraryDslModelUtility ecoreUtils;

	@Override
	public IScope getScope(EObject context, EReference reference) {
		// TODO Auto-generated method stub
		return super.getScope(context, reference);
	}

	/**
	 * Must supply only non abstract {@link CompositionModelType} elements.
	 * 
	 * @param context
	 * @param reference
	 * @return
	 */
	public IScope scope_CompositeModelInstance_compositeModelType(
			final CompositeModelInstance context, EReference reference) {

		IScope unfilteredScope = delegateGetScope(context,
				CompositeModelDslPackage.eINSTANCE
						.getCompositeModelInstance_CompositeModelType());
		IScope filtered = SelectableBasedScope.createScope(IScope.NULLSCOPE,
				new ScopeBasedSelectable(unfilteredScope),
				new Predicate<IEObjectDescription>() {
					public boolean apply(IEObjectDescription input) {
						EObject eObject = input.getEObjectOrProxy();
						if (eObject.eIsProxy()) {
							eObject = EcoreUtil.resolve(eObject, context);
						}
						Boolean abstractBool = (Boolean) eObject
								.eGet(ComponentTemplateLibraryDslPackage.eINSTANCE
										.getAbstractLibraryElement_Abstract());

						if (abstractBool != null
								&& abstractBool.booleanValue() == true)
							return false;
						return true;
					}
				}, CompositeModelDslPackage.eINSTANCE
						.getCompositeModelInstance(), true);
		return filtered;
	}

	/**
	 * Must supply only non abstract {@link ConstraintLinkType} elements.
	 * 
	 * @param context
	 * @param reference
	 * @return
	 */
	public IScope scope_ConstraintLinkInstance_constraintLinkType(
			final ConstraintLinkInstance context, EReference reference) {

		CompositionModelType current = (CompositionModelType) context
				.eContainer()
				.eGet(CompositeModelDslPackage.Literals.COMPOSITE_MODEL_INSTANCE__COMPOSITE_MODEL_TYPE);
		// get all composite in the hierarchy
		final EList<CompositionModelType> modelHierarchy = ecoreUtils
				.getHierarchy(
						CompositionModelType.class,
						current,
						ComponentTemplateLibraryDslPackage.Literals.COMPOSITION_MODEL_TYPE__SUPER_TYPE);

		IScope unfilteredScope = delegateGetScope(context,
				CompositeModelDslPackage.eINSTANCE
						.getConstraintLinkInstance_ConstraintLinkType());

		IScope filtered = SelectableBasedScope.createScope(
				IScope.NULLSCOPE,
				new ScopeBasedSelectable(unfilteredScope),
				new Predicate<IEObjectDescription>() {
					public boolean apply(IEObjectDescription input) {
						boolean allowed = false;
						EObject eObject = input.getEObjectOrProxy();
						if (eObject.eIsProxy()) {
							eObject = EcoreUtil.resolve(eObject, context);
						}
						// TODO can't extend from any child, so need to remove
						// them or add a flag allowing recursive linking.

						// must filter by CompositeModelType to show only
						// concrete and conceptual
						EList<CompositionModelType> allowedElements = ecoreUtils
								.getElementsFromHierarchy(
										CompositionModelType.class,
										eObject,
										ComponentTemplateLibraryDslPackage.Literals.CONSTRAINT_LINK_TYPE__SUPER_TYPE,
										ComponentTemplateLibraryDslPackage.Literals.ABSTRACT_LINK__ALLOWED_FOR);
						if (allowedElements.isEmpty())
							return false;

						for (CompositionModelType compositionModelType : allowedElements) {

							if (modelHierarchy.contains(compositionModelType)) {
								allowed = true;
							}
						}

						Boolean abstractBool = (Boolean) eObject
								.eGet(ComponentTemplateLibraryDslPackage.eINSTANCE
										.getAbstractLibraryElement_Abstract());

						if (abstractBool != null
								&& abstractBool.booleanValue() == true)
							allowed = false;

						return allowed;
					}
				}, ComponentTemplateLibraryDslPackage.eINSTANCE.getUnitType(),
				true);
		return filtered;
	}

	/**
	 * 
	 * @param context
	 * @param reference
	 * @return
	 */
	public IScope scope_LinkInstance_linkType(final LinkInstance context,
			EReference reference) {

		CompositionModelType current = (CompositionModelType) context
				.eContainer()
				.eGet(CompositeModelDslPackage.Literals.COMPOSITE_MODEL_INSTANCE__COMPOSITE_MODEL_TYPE);
		// get all composite in the hierarchy
		final EList<CompositionModelType> modelHierarchy = ecoreUtils
				.getHierarchy(
						CompositionModelType.class,
						current,
						ComponentTemplateLibraryDslPackage.Literals.COMPOSITION_MODEL_TYPE__SUPER_TYPE);

		IScope unfilteredScope = delegateGetScope(context,
				CompositeModelDslPackage.eINSTANCE.getLinkInstance_LinkType());

		IScope filtered = SelectableBasedScope.createScope(
				IScope.NULLSCOPE,
				new ScopeBasedSelectable(unfilteredScope),
				new Predicate<IEObjectDescription>() {
					public boolean apply(IEObjectDescription input) {
						boolean allowed = false;
						EObject eObject = input.getEObjectOrProxy();
						if (eObject.eIsProxy()) {
							eObject = EcoreUtil.resolve(eObject, context);
						}
						// TODO can't extend from any child, so need to remove
						// them.

						// must filter by CompositeModelType to show only
						// concrete and conceptual
						EList<CompositionModelType> allowedElements = ecoreUtils
								.getElementsFromHierarchy(
										CompositionModelType.class,
										eObject,
										ComponentTemplateLibraryDslPackage.Literals.LINK_TYPE__SUPER_TYPE,
										ComponentTemplateLibraryDslPackage.Literals.ABSTRACT_LINK__ALLOWED_FOR);
						if (allowedElements.isEmpty())
							return false;

						for (CompositionModelType compositionModelType : allowedElements) {

							if (modelHierarchy.contains(compositionModelType)) {
								allowed = true;
							}
						}

						Boolean abstractBool = (Boolean) eObject
								.eGet(ComponentTemplateLibraryDslPackage.eINSTANCE
										.getAbstractLibraryElement_Abstract());

						if (abstractBool != null
								&& abstractBool.booleanValue() == true)
							allowed = false;

						return allowed;
					}
				}, ComponentTemplateLibraryDslPackage.eINSTANCE.getUnitType(),
				true);
		return filtered;
	}

	public IScope scope_SourceEndPointInstance_requiredCapabilityCapture(
			final SourceEndPointInstance context, EReference reference) {
		if (context == null)
			return IScope.NULLSCOPE;

		UnitType targetUnit = context.getUnitInstance().getSuperType();
		final EList<RequiredCapabilityCapture> allowedElements = ecoreUtils
				.getElementsFromHierarchy(
						RequiredCapabilityCapture.class,
						targetUnit,
						ComponentTemplateLibraryDslPackage.Literals.UNIT_TYPE__SUPER_TYPE,
						ComponentTemplateLibraryDslPackage.Literals.UNIT_TYPE__REQUIRED_CAPABILITIES);

		IScope unfilteredScope = delegateGetScope(context, reference);

		IScope filtered = SelectableBasedScope.createScope(IScope.NULLSCOPE,
				new ScopeBasedSelectable(unfilteredScope),
				new Predicate<IEObjectDescription>() {
					public boolean apply(IEObjectDescription input) {
						EObject eObject = input.getEObjectOrProxy();
						if (eObject.eIsProxy()) {
							eObject = EcoreUtil.resolve(eObject, context);
						}
						if (allowedElements.contains(eObject)) {
							return true;
						}
						return false;
					}
				}, null, true);

		return filtered;

	}

	public IScope scope_SourceEndPointInstance_unitInstance(
			final SourceEndPointInstance context, EReference reference) {
		if (context == null)
			return IScope.NULLSCOPE;

		IScope unfilteredScope = delegateGetScope(context,
				CompositeModelDslPackage.eINSTANCE
						.getCompositeModelInstance_CompositeModelType());
		IScope filtered = SelectableBasedScope.createScope(IScope.NULLSCOPE,
				new ScopeBasedSelectable(unfilteredScope),
				new Predicate<IEObjectDescription>() {
					public boolean apply(IEObjectDescription input) {
						EObject eObject = input.getEObjectOrProxy();
						if (eObject.eIsProxy()) {
							eObject = EcoreUtil.resolve(eObject, context);
						}
						Boolean abstractBool = (Boolean) eObject
								.eGet(ComponentTemplateLibraryDslPackage.eINSTANCE
										.getAbstractLibraryElement_Abstract());

						if (abstractBool != null
								&& abstractBool.booleanValue() == true)
							return false;
						return true;
					}
				}, CompositeModelDslPackage.eINSTANCE
						.getCompositeModelInstance(), true);
		return filtered;
	}

	/**
	 * 
	 * @param context
	 * @param reference
	 * @return
	 */
	public IScope scope_TargetEndPointInstance_providedCapabilityCapture(
			final TargetEndPointInstance context, EReference reference) {
		if (context == null)
			return IScope.NULLSCOPE;
		UnitType targetUnit = context.getUnitInstance().getSuperType();
		final EList<ProvidedCapabilityCapture> allowedElements = ecoreUtils
				.getElementsFromHierarchy(
						ProvidedCapabilityCapture.class,
						targetUnit,
						ComponentTemplateLibraryDslPackage.Literals.UNIT_TYPE__SUPER_TYPE,
						ComponentTemplateLibraryDslPackage.Literals.UNIT_TYPE__PROVIDED_CAPABILITIES);

		IScope unfilteredScope = delegateGetScope(context, reference);

		IScope filtered = SelectableBasedScope.createScope(IScope.NULLSCOPE,
				new ScopeBasedSelectable(unfilteredScope),
				new Predicate<IEObjectDescription>() {
					public boolean apply(IEObjectDescription input) {
						EObject eObject = input.getEObjectOrProxy();
						if (eObject.eIsProxy()) {
							eObject = EcoreUtil.resolve(eObject, context);
						}
						if (allowedElements.contains(eObject)) {
							return true;
						}
						return false;
					}
				}, null, true);

		return filtered;

	}

	public IScope scope_TargetEndPointInstance_unitInstance(
			final TargetEndPointInstance context, EReference reference) {
		if (context == null)
			return IScope.NULLSCOPE;

		IScope unfilteredScope = delegateGetScope(context,
				CompositeModelDslPackage.eINSTANCE
						.getCompositeModelInstance_CompositeModelType());
		IScope filtered = SelectableBasedScope.createScope(IScope.NULLSCOPE,
				new ScopeBasedSelectable(unfilteredScope),
				new Predicate<IEObjectDescription>() {
					public boolean apply(IEObjectDescription input) {
						EObject eObject = input.getEObjectOrProxy();
						if (eObject.eIsProxy()) {
							eObject = EcoreUtil.resolve(eObject, context);
						}
						Boolean abstractBool = (Boolean) eObject
								.eGet(ComponentTemplateLibraryDslPackage.eINSTANCE
										.getAbstractLibraryElement_Abstract());

						if (abstractBool != null
								&& abstractBool.booleanValue() == true)
							return false;
						return true;
					}
				}, CompositeModelDslPackage.eINSTANCE
						.getCompositeModelInstance(), true);
		return filtered;

	}

	/**
	 * This scope returns only elements allowed for CompositionModeType and not
	 * abstract.
	 * 
	 * @param context
	 * @param reference
	 * @return
	 */
	public IScope scope_UnitInstance_superType(final UnitInstance context,
			EReference reference) {

		CompositionModelType current = (CompositionModelType) context
				.eContainer()
				.eGet(CompositeModelDslPackage.Literals.COMPOSITE_MODEL_INSTANCE__COMPOSITE_MODEL_TYPE);
		// get all composite in the hierarchy
		final EList<CompositionModelType> modelHierarchy = ecoreUtils
				.getHierarchy(
						CompositionModelType.class,
						current,
						ComponentTemplateLibraryDslPackage.Literals.COMPOSITION_MODEL_TYPE__SUPER_TYPE);

		IScope unfilteredScope = delegateGetScope(context,
				CompositeModelDslPackage.eINSTANCE.getUnitInstance_SuperType());

		IScope filtered = SelectableBasedScope.createScope(
				IScope.NULLSCOPE,
				new ScopeBasedSelectable(unfilteredScope),
				new Predicate<IEObjectDescription>() {
					public boolean apply(IEObjectDescription input) {
						boolean allowed = false;
						EObject eObject = input.getEObjectOrProxy();
						if (eObject.eIsProxy()) {
							eObject = EcoreUtil.resolve(eObject, context);
						}
						// TODO can't extend from any child, so need to remove
						// them.

						// must filter by CompositeModelType to show only
						// concrete and conceptual
						EList<CompositionModelType> allowedElements = ecoreUtils
								.getElementsFromHierarchy(
										CompositionModelType.class,
										eObject,
										ComponentTemplateLibraryDslPackage.Literals.UNIT_TYPE__SUPER_TYPE,
										ComponentTemplateLibraryDslPackage.Literals.UNIT_TYPE__ALLOWED_FOR_MODEL_TYPES);
						if (allowedElements.isEmpty())
							return false;

						for (CompositionModelType compositionModelType : allowedElements) {

							if (modelHierarchy.contains(compositionModelType)) {
								allowed = true;
							}
						}

						Boolean abstractBool = (Boolean) eObject
								.eGet(ComponentTemplateLibraryDslPackage.eINSTANCE
										.getAbstractLibraryElement_Abstract());

						if (abstractBool != null
								&& abstractBool.booleanValue() == true)
							allowed = false;

						return allowed;
					}
				}, ComponentTemplateLibraryDslPackage.eINSTANCE.getUnitType(),
				true);
		return filtered;
	}

}
