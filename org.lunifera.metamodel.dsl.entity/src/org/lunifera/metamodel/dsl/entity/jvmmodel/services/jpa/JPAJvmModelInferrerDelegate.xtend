/**
 * Copyright (c) 2011 - 2012, Florian Pirchner - lunifera.org
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Sources generated by Xtext  
 * 
 * Contributors:
 *  		Florian Pirchner - Initial implementation
 */
package org.lunifera.metamodel.dsl.entity.jvmmodel.services.jpa

import com.google.inject.Inject
import org.eclipse.xtext.common.types.util.TypeReferences
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.lunifera.metamodel.entity.entitymodel.LCompilerType
import org.lunifera.metamodel.entity.entitymodel.LContainer
import org.lunifera.metamodel.entity.entitymodel.LContains
import org.lunifera.metamodel.entity.entitymodel.LEmbedds
import org.lunifera.metamodel.entity.entitymodel.LEntity
import org.lunifera.metamodel.entity.entitymodel.LEntityModel
import org.lunifera.metamodel.entity.entitymodel.LEnum
import org.lunifera.metamodel.entity.entitymodel.LGenSettings
import org.lunifera.metamodel.entity.entitymodel.LOperation
import org.lunifera.metamodel.entity.entitymodel.LProperty
import org.lunifera.metamodel.entity.entitymodel.LReference
import org.lunifera.metamodel.dsl.entity.extensions.ModelExtensions
import org.lunifera.metamodel.dsl.entity.jvmmodel.services.IEntityJvmModelInferrerDelegate
import org.lunifera.metamodel.dsl.entity.jvmmodel.services.entity.EntityTypesBuilder
import org.lunifera.metamodel.entity.entitymodel.LRefers

/**
 * Difference to EntityJvmModelInferrerDelegate:<br>
 * Embedds references are not inlined. They are treated as simple references and annotated with @java.persistence.Embedds
 */
class JPAJvmModelInferrerDelegate implements IEntityJvmModelInferrerDelegate {
	
    /**
     * conveninence API to build and initialize JvmTypes and their members.
     */
	@Inject extension EntityTypesBuilder 
	@Inject extension IQualifiedNameProvider
	@Inject extension ModelExtensions
	@Inject TypeReferences references
	
	override isResponsible(LCompilerType lCompilerType) {
		lCompilerType.compilesToJPAModel
	}
	
   		/**
	 * Is called for each instance of the first argument's type contained in a resource.
	 * 
	 * @param element - the model to create one or more JvmDeclaredTypes from.
	 * @param acceptor - each created JvmDeclaredType without a container should be passed to the acceptor in order get attached to the
	 *                   current resource.
	 * @param isPreLinkingPhase - whether the method is called in a pre linking phase, i.e. when the global index isn't fully updated. You
	 *        must not rely on linking using the index if iPrelinkingPhase is <code>true</code>
	 */
	 @SuppressWarnings({"deprecation"})
   	 override void infer(LEntity e, IJvmDeclaredTypeAcceptor acceptor, boolean isPrelinkingPhase) {
   	 	val LEntityModel model = e.getPackage().eContainer as LEntityModel
   	 	val LGenSettings settings = model.genSettings
		acceptor.accept(
 			e.toEntityClass( e.fullyQualifiedName, settings)
			).initializeLater [
				documentation = e.documentation
				if (e.superType != null){
					superTypes += references.getTypeForName(e.superType.fullyQualifiedName.toString, e, null)
				}

				members += e.toConstructor() []
					
				if(settings.lifecycleHandling && e.superType == null){
					members += e.toPrimitiveTypeField("disposed", Boolean::TYPE)
				}
				//
				// fields
				//
				for ( f : e.entityMembers ) {
					switch f {
						LProperty: {
							members += f.toField(f.name, f.toTypeReference())
						}
						
						LEmbedds: {
							if(f.fullyQualifiedName != null && !f.fullyQualifiedName.empty){
								members += f.toField(f.name, f.toTypeReference())
							}
						}
						
						LContainer: {
							if(f.fullyQualifiedName != null && !f.fullyQualifiedName.empty){
								if(f.opposite != null){
									members += e.toPrimitiveTypeField("setting"+f.name.toFirstUpper, Boolean::TYPE)
								}
								members += f.toField(f.name, f.toTypeReference())
							}
						}
						
						LContains: {
							if(f.fullyQualifiedName != null && !f.fullyQualifiedName.empty){
								if(f.opposite != null){
									members += e.toPrimitiveTypeField("setting"+f.name.toFirstUpper, Boolean::TYPE)
								}
								members += f.toField(f.name, f.toTypeReference())
							}
						}
						
						LRefers: {
							if(f.fullyQualifiedName != null && !f.fullyQualifiedName.empty){
								members += f.toField(f.name, f.toTypeReference())
							}
						}
					}
				}
				
				//
				// methods
				//
				if(settings.lifecycleHandling){
					if(e.superType == null){
						members += e.toIsDisposed()
					}
					members += e.toCheckDisposed()
					members += e.toDispose()
				}
				
				for ( f : e.entityMembers ) {
					switch f {
						LProperty : {
							members += f.toGetter(f.name, settings)
							if(!f.toMany){
								members += f.toSetter(f.name, settings)
							} else {
								members += f.toAdder(f.name, settings)	
								members += f.toRemover(f.name, settings)		
								members += f.toEnsureReferenceList(f.name)
							}
						}
						
						LReference : {
							members += f.toGetter(f.name, settings)
							if(!f.toMany){
								members += f.toSetter(f.name, settings)		
							} else {
								members += f.toAdder(f.name, settings)	
								members += f.toRemover(f.name, settings)		
								members += f.toEnsureReferenceList(f.name)
							}
						}
						
						LEmbedds : {
							members += f.toGetter(f.name, settings)
							members += f.toSetter(f.name, settings)	
						}
						
						LContainer : {
//							members += f.toGetter(f.name, settings)
//							if(!f.toMany){
//								members += f.toSetter(f.name, settings)		
//							} else {
//								members += f.toAdder(f.name, settings)	
//								members += f.toRemover(f.name, settings)		
//								members += f.toEnsureReferenceList(f.name)
//							}
						}
						
						LContains: {
//							members += f.toGetter(f.name, settings)
//							if(!f.toMany){
//								members += f.toSetter(f.name, settings)		
//							} else {
//								members += f.toAdder(f.name, settings)	
//								members += f.toRemover(f.name, settings)		
//								members += f.toEnsureReferenceList(f.name)
//							}
						}

						LOperation: {
							members += f.toMethod(f.name, f.type) [
								documentation = f.documentation
								for (p : f.params) {
									parameters += p.toParameter(p.name, p.parameterType)
								}
								body = f.body
							]
						}
					}
				}
			]
   	}
   	
   	/**
	 * Is called for each instance of the first argument's type contained in a resource.
	 * 
	 * @param element - the model to create one or more JvmDeclaredTypes from.
	 * @param acceptor - each created JvmDeclaredType without a container should be passed to the acceptor in order get attached to the
	 *                   current resource.
	 * @param isPreLinkingPhase - whether the method is called in a pre linking phase, i.e. when the global index isn't fully updated. You
	 *        must not rely on linking using the index if iPrelinkingPhase is <code>true</code>
	 */
	 @SuppressWarnings({"deprecation"})
   	 override void infer(LEnum e, IJvmDeclaredTypeAcceptor acceptor, boolean isPrelinkingPhase) {
		acceptor.accept(
 			e.toEnumerationType(e.fullyQualifiedName.toString, null)
			).initializeLater [
				documentation = e.documentation
				//
				// literals
				//
				for ( f : e.literals ) {
					documentation = f.documentation
					members+=f.toEnumerationLiteral(f.name)
				}
			]
   	}
}